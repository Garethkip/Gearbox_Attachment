<!DOCTYPE html>
<html>

<head>
    <title>MODULE 4</title>
    <link rel="stylesheet" href="Module-4/Module4.css">
</head>

<body>
    <div id="head">
        <h1>MICROCONTROLLER PROGRAMMING AND ACCESS CONTROL SYSTEMS 2</h1>
        <img id="back_image" src="Pictures/pic1.jpg">
    </div>
    <div id="Info">
        <div id="Task1">
            <h1>Communication Protocols in Embedded Systems.</h1>
            <h2>Working with communication protocols (I2C,UART,SPI)</h2>
            <p>
                Sometimes a device may have more than one embedded system, each performing a different task and for the system to work efficiently, good communication must exist between the subsystems. A common communication protocol is chosen to allow exchange of data
                and information. There are numerous protocols to be selected but due to standardization, they are broadly categorised into 2:
                <div class="Pic">
                    <img src="Pictures\interfaces.webp">
                </div>
                <ol>
                    <li><strong>Parallel Interface</strong> - Multiple bits are transferred at the same time following a rising or falling clock edge.

                    </li>
                    <li>
                        <strong>Serial Interface</strong> - Data is transmitted one bit at a time as a stream.Uses less wires than Parallel interface and is cheaper.
                        <br> The serial interface is further classified mainly into 3:
                        <ul>
                            <li><strong>I2C (Inter Integrated Circuit)</strong></li>
                            <li><strong>SPI(Serial Peripheral Interface)</strong></li>
                            <li><strong>UART(Universal Asynchronous Receiver/Transmitter)</strong></li>
                        </ul>
                    </li>
                </ol>
                <ol type="A">
                    <li>
                        <strong>I2C</strong><br>
                        <div class="Pic">
                            <img src="Pictures\i2c.jpeg">
                        </div> It uses only 2 bi-directional open-drain lines for data transmission called <strong>SDA</strong> and <strong>SCL.</strong><br> SDA(Serial Data)-facilitates the transfer of data.<br> SCL(Serial Clock) - Carries the clock<br>                        I2C operates in 2 modes: <strong>Master mode</strong> and <strong>Slave mode.</strong>

                        <h3>Advantages of I2C</h3>
                        <ol>
                            <li>Can have multiple masters</li>
                            <li>Reduced complexity due to use of only 2 wires unlike SPI.</li>
                            <li>Cost-efficient.</li>
                            <li>Uses ACK(Acknowledge) bit which reduces error.</li>
                        </ol>
                        <h3>Disadvantages of I2C</h3>
                        <ol>
                            <li>Slower speed since bits are sent and received one at a time.</li>
                            <li>Data can be bi-directional but supports only one direction at a time (Half-duplex).</li>
                        </ol>
                    </li>
                    <li><strong>SPI</strong><br>
                        <div class="Pic">
                            <img src="Pictures\spi.jpeg">
                        </div>It is used to facilitate communication between peripheral devices(input and output devices and microcontrollers).It featues full-duplex and synchronous communication between one or more slave devices and a microcontroller.
                        <br> The components of SPI include:
                        <ul>
                            <li>
                                <strong>Master Device</strong> - It controls the data flow and generates the clock signal(Microcontroller).
                            </li>
                            <li>
                                <strong>Slave Device</strong> - Are peripheral devices controlles by the master device.
                            </li>
                            <li>
                                <strong>SPI Bus</strong> - It refers to the physical connections allowing the data to move between the slave devices and master device.<br> SPI is made up of :<br>
                                <ol>
                                    <li>Slave Select(SS) - Allows the master to communicate to a specific slave.</li>
                                    <li>Master Out Slave In(MOSI) - Allows communication from Master to slave.</li>
                                    <li>Master In Slave Out(MISO) - Allows communication from slave to Master.</li>
                                    <li>Serial Clock(SCK) - Clock used by master and slave devices to coordinate data transfer.</li>
                                </ol>
                            </li>
                            <li>
                                <strong>Data Transfer Protocol</strong> - SPI uses synchronous(controlled by a clock) serial communication for full duplex(data transfer in both ways simultaneously) data transfer.
                            </li>
                            <li>
                                <strong>Data Rate</strong> - Number of bits transferred per second .
                            </li>
                            <li>
                                <strong>Clock Polarity and Clock Phase</strong> - used to define the relationship between the data signals and the clock signals.
                            </li>
                        </ul>
                        <h3>Advantages of SPI.</h3>
                        <ol>
                            <li>High speed data transfer</li>
                            <li>Simple Hardware Requirements.(4 signal lines-SCK,MISO,MOSI,SS)</li>
                            <li>Supports Full duplex communication.</li>
                            <li>Supports multiple slave devices.</li>
                        </ol>
                        <h3>Disadvantages of SPI.</h3>
                        <ol>
                            <li>Used more wires than I2C.</li>
                        </ol>
                    </li>
                    <li>
                        <strong>UART</strong><br>
                        <div class="Pic">
                            <img src="Pictures\uart.png">
                        </div> It allows for asynchronous serial communication between devices.UART is a block of circuitry responsible for implementing serial communication as it acts as an intermediary between parallel and serial interfaces. On one
                        end of the UART is a bus of 8 or so data lines and control pins and the other is the two serial wires, RX and TX (Receiver and Transmitter)<br>
                        <br> Although it has been greatly replaced by SPI and I2Cs, it's widely used for lower-speed applications because it is very simple, low-cost and easy to implement.<br>
                        <h3>Advantages of UART</h3><br>
                        <ol>
                            <li>It supports full-duplex communication.</li>
                            <li>It doesn't require a clock signal.</li>
                            <li>Has error checking due to the presence parity bit</li>
                            <li>Data format and transmission speeds are configurable.</li>
                        </ol>
                        <h3>Disadvantages of UART</h3>
                        <ol>
                            <li>Lower Data Rates</li>
                            <li>Suitable for only 2 devices</li>
                            <li>Has a distance limit of 15 meters.</li>
                        </ol>
                    </li>
                </ol>
            </p>

            <h2>Interfacing the RPi Pico and ESP32 using SPI</h2>
            <p>
                The following code was used in sending data from a raspberry pi pico (Master) to an ESP32 (slave) using SPI.
                <h3>Raspberry pi pico code(SPI master)</h3>
                <div class="Combined">
                    <pre>
                        <code>
    import machine
    from machine import Pin
    from time import sleep
    
    
    led=machine.Pin(25,Pin.OUT)
    # Configure SPI pins
    spi_sck = Pin(18)
    spi_tx = Pin(19)
    spi_rx = Pin(16)
    slave_select_pin = Pin(10, Pin.OUT)
    
    # Initialize SPI as master
    spi = machine.SPI(0, baudrate=9600, polarity=0, phase=0, sck=spi_sck, mosi=spi_tx, miso=spi_rx)
    
    while True:
        # Select the slave (assert CS)
        slave_select_pin.value(0)
        led.value(1)
        sleep(1)
        # Send data to the slave
        tx_data = b'\x10'
        spi.write(tx_data)
        print("Sent data from master: ",tx_data[0])
    
        # Receive data from the slave
        rx_data = spi.read(1)
        
        # Deselect the slave (deassert CS)
        slave_select_pin.value(1)
        led.value(0)
    
        print("Received data from slave:", rx_data[0])
        
        sleep(1)      
                        </code>
                    </pre>
                </div>
                <h3>ESP32 code(SPI slave)</h3>
                <div class="Combined">
                    <pre>
                        <code>
    #include &ltSPI.h&gt

        const int slaveSelectPin = 5; // GPIO pin connected to slave select (CS)
        const int led=2;
        void setup() {
            Serial.begin(9600);
            pinMode(slaveSelectPin, OUTPUT);
            pinMode(led,OUTPUT);
            
            SPI.begin(); // Initialize SPI
            digitalWrite(led,LOW);
            digitalWrite(slaveSelectPin,HIGH);
            delay(1000);
        }
        
        void loop() {
            // Wait for the master to select the slave (CS low)
            while (digitalRead(slaveSelectPin)) {
                Serial.print("Waiting .... ");
                Serial.println(digitalRead(slaveSelectPin));
                digitalWrite(led,HIGH);
                delay(1000);
            }
            // Send response back to the master
            uint8_t txData = 0x12;
            uint8_t rxData=SPI.transfer(txData);
            Serial.print("Sent data from slave: ");
            Serial.println(txData);
        
            // Receive data from the master
            Serial.print("Received data from master: ");
            Serial.println(rxData);
            // Process received data (e.g., perform an action)
        
            
        
            // Wait for the master to deselect the slave (CS high)
            while (!digitalRead(slaveSelectPin)) {
                digitalWrite(led,LOW);
                Serial.print("DESELECTING .... ");
                Serial.println(digitalRead(slaveSelectPin));
                delay(1000);
            }
            Serial.println("---------------------------");
        }
                        </code>
                    </pre>
                </div>
            </p>
            <h2>Interfacing the RPi Pico and ESP32 using I2C</h2>
            <p>
                The following code was used in sending data from a raspberry pi pico (Master) to an ESP32 (slave) using I2C.
                <h3>Raspberry pi pico code (I2C Master)</h3>
                <div class="Combined">
                    <pre>
                        <code>
    # Raspberry Pi Pico (Master) - MicroPython

    from machine import Pin, SoftI2C
    import time
    
    # Initialize I2C communication
    i2c = SoftI2C(scl=Pin(5), sda=Pin(4))
    
    # I2C slave address of the ESP32
    slave_address = 0x42
    
    def send_data_to_slave(data):
        try:
            i2c.writeto(slave_address, data)
            print(f"Sent data to slave: {data}")
        except OSError:
            print("Error sending data to slave.")
    
    def main():
        while True:
            # Example: Send a byte (0xAA) to the slave
            send_data_to_slave(b'\xAA')
            time.sleep(1)
    
    if __name__ == "__main__":
        main()    
                        </code>
                    </pre>
                </div>
                <h3>ESP32 code (I2C Slave)</h3>
                <div class="Combined">
                    <pre>
                        <code>
    // ESP32 (Slave) - C

    #include &ltWire.h&gt
    
    // I2C address (must match the master's address)
    #define SLAVE_ADDRESS 0x42
    
    void setup() {
        Wire.begin(21,22,SLAVE_ADDRESS); // Initialize I2C as slave
        Wire.onReceive(receiveData);
        Serial.begin(115200);
    }
    
    void receiveData(int byteCount) {
        while (Wire.available()) {
            char receivedData = Wire.read();
            Serial.print("Received data from master: ");
            Serial.println(receivedData);
            // Process received data (e.g., control an LED, update sensor readings, etc.)
        }
        
    }
    
    void loop() {
        // Your code here
        // Continue processing or wait for more data from the master
    }                                                   
                        </code>
                    </pre>
                </div>
            </p>
            <h2>Interfacing the RPi Pico and ESP32 using Serial Communication.</h2>
            <p>
                The following code was used in sending data from a raspberry pi pico (Master) to an ESP32 (slave) using UART protocol.
                <h3>Raspberry pi pico code (UART Master)</h3>
                <div class="Combined">
                    <pre>
                        <code>
    from machine import UART, Pin

    # Initialize UART
    uart = UART(0, baudrate=9600, tx=Pin(0), rx=Pin(1))
    
    # Send data (master to slave)
    uart.write("Hello, ESP32!")
    
    # Receive data (slave to master)
    received_data = uart.read()
    print("Received data from ESP32:", received_data)
                        </code>
                    </pre>
                </div>
                <h3>ESP32 code (UART Master)</h3>
                <div class="Combined">
                    <pre>
                        <code>
    #include &ltHardwareSerial.h&gt

        void setup() {
            Serial.begin(9600); // Initialize UART
        }
        
        void loop() {
            // Receive data from master (Raspberry Pi Pico)
            if (Serial.available()) {
                char receivedChar = Serial.read();
                // Process received data (e.g., control sensors, LEDs, etc.)
                // Send response back to the master if needed
            }
        }      
                        </code>
                    </pre>
                </div>
            </p>
            <h2>Communication between two raspberry pi pico Ws on the same network.</h2>
            <p>
                Coming soon &#128517
            </p>
            <h3>Configuring the raspberry pi pico W as a server in a network.</h3>
            <p>
                Raspberry pi pico W is equiped with wifi hence can act as a server of webpages to clients.This benefit allows us to build websites that allow us to control devices remotely provided there is an internet connection. Internet Of Things uses this ability
                extensively to allow for wireless communication to take place between devices and their users. Raspberry Pi Pico W when pregrammed as a server using Micropython, results in less bulky code as compared to ESP32 hence RPi Pico W is often
                preffered in IOT applications.<br>The following code shows the basic structure of a Pico W server that perfoms the action of turning on or off the onboard led. Ater the code has uploaded, proceed to your browser and enter
                the correct IP Address (printed in the terminal).
                <div class="Combined">
                    <pre>
                        <code>
    import network
    import socket
    from time import sleep
    from picozero import pico_temp_sensor, pico_led
    import machine

    ssid = 'GEARBOX MEMBERS'
    password = 'Members@Gearbox'

    def connect():
    #Connect to WLAN
    wlan = network.WLAN(network.STA_IF)
    wlan.active(True)
    wlan.connect(ssid, password)
    while wlan.isconnected() == False:
        print('Waiting for connection...')
        sleep(1)
    ip = wlan.ifconfig()[0]
    print(f'Connected on {ip}')
    return ip

    def open_socket(ip):
    # Open a socket
    address = (ip,80)
    connection = socket.socket()
    connection.bind(address)
    connection.listen(1)
    return connection

    def webpage(temperature, state):
    #Template HTML
    html = f"""
            &lt!DOCTYPE html&gt
            &lthtml&gt
            &ltform action="./lighton"&gt
            &ltinput type="submit" value="Light on" /&gt
            &lt/form&gt
            &ltform action="./lightoff"&gt
            &ltinput type="submit" value="Light off" /&gt
            &lt/form&gt
            &ltp&gtLED is {state}&lt/p &gt
            &ltp&gtTemperature is {temperature}&lt/p&gt
            &lt/body&gt
            &lt/html&gt
            """
    return str(html)

    def serve(connection):
    #Start a web server
    state = 'OFF'
    pico_led.off()
    temperature = 0
    while True:
        client = connection.accept()[0]
        request = client.recv(1024)
        request = str(request)
        
        try:
            request = request.split()[1]
        except IndexError:
            pass
        if request == '/lighton?':
            pico_led.on()
            state = 'ON'
        elif request =='/lightoff?':
            pico_led.off()
            state = 'OFF'
        temperature = pico_temp_sensor.temp
        html = webpage(temperature, state)
        client.send(html)
        client.close()

    try:
    ip = connect()
    connection = open_socket(ip)
    serve(connection)
    print(connection)
    except KeyboardInterrupt:
    machine.reset()

                        </code>
                    </pre>
                </div>This basic structure remains constant as complexity increases hence it has fairly good scalability properties.
            </p>
            <h3>Configuring the ESP32 as a server in a network.</h3>
            <p>
                Coming soon &#128517
            </p>

            <h2>Blynk Cloud Setup using ESP32</h2>
            <p>
                Blynk is an remote server that allows clients to build simple control panels for their projects without prior knowledge in website design. The panel has buttons sliders and many more which can send data to to your board or read and display data on the
                panel such as temperature readings.<br> The following is the process of linking your ESP32 to Blynk :
                <ol>
                    <li>
                        Login to your blynk account.
                    </li>
                    <li>
                        Create a new template then proceed to the datastream section and create a pin(digital,analog,virtualpin,input or output) which is used to send or receive data.
                    </li>
                    <li>
                        Proceed to the home section while still in your template and create the control feature you wish to use such as a switch and attach it to a datastream you created. </li>
                    <li>
                        Copy your template's authentication token,template name and template id.Save your changes.
                    </li>
                    <li>
                        Proceed to your 'Devices' and create a device from your template.Save it.
                    </li>
                    <li>
                        Proceed to your Arduino IDE and upload the following code to your ESP32.Its a simple code of toggling the onboard LED from Blynk Website.
                    </li>
                </ol>
                <div class="Combined">
                    <pre>
                        <code>
    #define BLYNK_TEMPLATE_ID "TMPL280pQpoeq"
    #define BLYNK_TEMPLATE_NAME "blinkled"
    #define BLYNK_AUTH_TOKEN "ZmIs2CUiuUgsSQ5Rud4iohQJVUWS-jBi"
    
    #define BLYNK_PRINT Serial
    #include &ltBlynk.h&gt
    #include &ltBlynkSimpleEsp32.h&gt
    #include &ltWiFi.h&gt
    #include &ltWiFiClient.h&gt
    
    // Your WiFi credentials.
    const char auth[] = BLYNK_AUTH_TOKEN;
    const char ssid[] = "Your wifi name";
    const char pass[] = "********";
    
    void setup() {
        Serial.begin(9600);
        Blynk.begin(auth, ssid, pass,"blynk.cloud",80);
    }
    
    void loop() {
        Blynk.run();
        // Your other code here
    }      
                        </code>
                    </pre>
                </div>
            </p>
        </div>
        <div id="Task2">
            <h1>PROJECT 2</h1>
            <p>
                Coming soon &#128517
            </p>
        </div>

        <div id="Footer">
            <h1>THE END OF MODULE 4 &#128516</h1>
        </div>
    </div>

</body>

</html>